<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="../../static/css/style.css">
<link rel="Stylesheet" type="text/css" href="../../static/bootstrap-3.1.1/css/bootstrap.min.css">
<link rel="Stylesheet" type="text/css" href="../../static/css/wiki.css">

<script type="text/javascript" src="../../static/js/jquery-1.11.0.js"></script>
<script type="text/javascript" src="../../static/bootstrap-3.1.1/js/bootstrap.min.js"></script>

<script type="text/javascript" src="../../static/js/xregexp-all.js"></script> <!-- XRegExp is bundled with the final shCore.js during build -->
<!-- 利用pin.js使toc固定在屏幕左侧-->
<script type="text/javascript" src="../../static/js/jquery.pin.js"></script> 

<script type="text/javascript" src="../../static/js/syntaxhighlighter/shCore.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shLegacy.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushAppleScript.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushAS3.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushBash.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushColdFusion.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushCpp.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushCSharp.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushCss.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushDelphi.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushDiff.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushErlang.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushGroovy.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushJava.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushJScript.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushPerl.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushPhp.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushPlain.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushPowerShell.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushPython.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushRuby.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushSass.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushScala.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushSql.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushVb.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushXml.js"></script>
<!-- 自定义笔刷 -->
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushLaTex.js"></script>
<script type="text/javascript" src="../../static/js/syntaxhighlighter/shBrushVimScript.js"></script>
<!-- 加入数学公式的支持 -->
<!--
<script type="text/javascript" src="../../static/js/mathJax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
-->
<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<link type="text/css" rel="stylesheet" href="../../static/css/syntaxhighlighter/shCoreDefault.css"/>
<link type="text/css" rel="stylesheet" href="../../static/css/font-awesome.css"/>

<title>concurrent</title>
<!-- <meta http-equiv="Content-Type" content="text/html; charset=utf-8"> -->
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
	<body>
		<div class="container">
			<nav class="navbar navbar-inverse" role="navigation">
				<div class="navbar-header">
					<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
						<span class="sr-only">Toggle navigation</span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
						<span class="icon-bar"></span>
					</button>
				<a class="navbar-brand">Ollie's Wiki</a>
				</div>
				<div class="collapse navbar-collapse">
					<ul class="nav navbar-nav">
						<li><a href="../../index.html"><i class="icon-home"></i> Home</a></li>
						<li><a href="../../NoteBook/index.html"><i class="icon-pencil"></i> NoteBook</a></li>
						<li><a href="../../TodoList/index.html"><i class="icon-ok"></i> TodoList</a></li>
						<li><a href="../../BookList/index.html"><i class="icon-book"></i> BookList</a></li>
						<li><a href="../../diary/diary.html"><i class="icon-coffee"></i> Diary</a></li>
					</ul>
				</div>
			</nav>
		</div>
		<div class="container content-body">
			<div class="content">
			
<h1 id="toc_1">并发类</h1>
<p>
线程状态：不可调度，可调度，
wait 所属的等待队列
</p>
<ul>
<li>
对象所属的等待队列

</ul>
<h2 id="toc_1.1">CAS(Compare and Set)</h2>
<p>
 <strong>读写同时发生操作系统保证先写后读</strong>
</p>
<h2 id="toc_1.2">ConcurrentHashMap</h2>
<ol>
<li>
分段

<ol>
<li>
分为多个segment（固定数目），每一个就是一个小hashMap，两次hash定位到segment，对HashMap的操作，GET值，如果GET到null，则加锁，重新GET。SET操作，自旋操作！

<li>
无阻塞所，无读写锁

</ol>
<li>
利用modifyCount

<li>
每一个小HashMap超过装载因子的话，先扩容，再存

</ol>

<h2 id="toc_1.3">ConcurrentLinkedQueue</h2>
<h3 id="toc_1.3.1">入队</h3>
<ol>
<li>
创建节点（可以并发）

<li>
将原来tail指向的节点的next指向新节点（问题，可能tail指向的节点已经不是最后一个节点（被其他线程改过一半））*问题的关键*

<li>
tail指向新节点(如果更改tail指针时，新节点的next不为null，就不进行该操作，因为其他新增节点的线程一定一定已经将tail指针指向了最后一个节点)

</ol>

<p>
第二个问题：就是通过CAS操作：获取tail然后CAS，如果set时，tail发生变化，就重新获取tail
</p>
<h3 id="toc_1.3.2">出队</h3>
<ol>
<li>
获得head指向的节点（获得了head节点，但是节点里面的内容已经被其他节点出队了）

<ul>
<li>
 所以：首先判断节点是否为空，如果不为空，CAS head为空，如果CAS成功，则返回该节点，如果不成功，说明别的线程已经将其出队，重新获得head节点，再试。

</ul>
<li>
更新head指针的指向（CAS成功的线程，其他线程由于CAS失败，将会重新获得Head指向的节点）

</ol>

<h2 id="toc_1.4">CopyOnWriteArrayList</h2>
<p>
写时先复制一份，改完在更新原来指针指向
</p>

<h2 id="toc_1.5">读写锁</h2>
<p>
阻塞式，自旋式
</p>

<ol>
<li>
读读不互斥

<li>
读写互斥

<li>
写写互斥

<li>
同一线程部分读写，可重入

<li>
读锁可升级为写锁，写锁可以降级为读锁

</ol>

<h3 id="toc_1.5.1">信号量</h3>
<ol>
<li>
readers：读请求获得该锁，该值++；

<li>
writers：写请求获得该锁，该值--（由于读读互斥，同时只能有一个线程获得该锁，所以该值只能是0或1）

<li>
requestWriters：(类似一种排队策略，防止写请求饿死：即便写请求不能获得锁，也将++该值，以后就没有读请求可以获得这个锁了，当前读请求执行完后，notifyAll所有阻塞的写请求)

</ol>

<ul>
<li>
线程申请读锁，条件writers=0，requestWriters=0；

<li>
线程申请写锁，条件readers=0，如果申请不到，requestWriters++；

</ul>

<h3 id="toc_1.5.2">可重入特性</h3>
<ul>
<li>
为了实现可重入，锁需要有map，保存线程==&gt;线程获得锁的次数

<ul>
<li>
 map:key=&gt;thread value=&gt;int(获得锁++，释放--)

</ul>
<li>
当一个线程释放锁后，map中的value减为0，则readers--

</ul>
<p>
TIPS：因为对map的操作都是同步操作，所以不需要该Map为线程安全容器
</p>

<h3 id="toc_1.5.3">升降级特性</h3>
<ul>
<li>
有且只有当前线程获得读锁，才能升级为写锁。即readlock==1时，就可以升级为写锁,同时将会把readlock--，最后直接unlock写锁就好了！

<li>
写锁直接可以降级为读锁；

</ul>


			<hr>
			<div id="disqus_thread"></div>
			</div>
		</div>
		<script type="text/javascript" src="../../static/js/wiki.js"></script>
		<script type="text/javascript">
			/* * * CONFIGURATION VARIABLES * * */
			var disqus_shortname = 'olliewiki';

			/* * * DON'T EDIT BELOW THIS LINE * * */
			(function() {
				var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
				dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
				(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
			})();
		</script>
		<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
	</body>
</html>
